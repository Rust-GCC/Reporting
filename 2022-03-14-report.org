#+title:  Weekly Report for 7th to 14th March March 2022
#+author: Philip Herron
#+date:   2022-03-07

** Overview

Thanks again to [[https://opensrcsec.com/][Open Source Security, inc]] and [[https://www.embecosm.com/][Embecosm]] for their ongoing support for this project.

*** Milestone Progress

TODO

** Completed Activities

*** Contributors this month

- [[https://github.com/CohenArthur][Arthur Cohen]]

*** Overall Task Status

| Category    | Last Week | This Week | Delta |
|-------------+-----------+-----------+-------|
| TODO        |       113 |           |       |
| In Progress |        17 |           |       |
| Completed   |       306 |           |       |

*** Test Cases

| TestCases | Last Week | This Week | Delta |
|-----------+-----------+-----------+-------|
| Passing   | 6177      |           |       |
| Failed    | -         |           |       |
| XFAIL     | 21        |           |       |
| XPASS     | -         |           |       |

*** Bugs

| Category    | Last Week | This Week | Delta |
|-------------+-----------+-----------+-------|
| TODO        |        38 |           |       |
| In Progress |         6 |           |       |
| Completed   |       112 |           |       |

*** Milestones Progress

| Milestone                         | Last Week | This Week | Delta | Start Date     | Completion Date | Target         |
|-----------------------------------+-----------+-----------+-------+----------------+-----------------+----------------|
| Data Structures 1 - Core          |      100% |      100% | -     | 30th Nov 2020  | 27th Jan 2021   | 29th Jan 2021  |
| Control Flow 1 - Core             |      100% |      100% | -     | 28th Jan 2021  | 10th Feb 2021   | 26th Feb 2021  |
| Data Structures 2 - Generics      |      100% |      100% | -     | 11th Feb 2021  | 14th May 2021   | 28th May 2021  |
| Data Structures 3 - Traits        |      100% |      100% | -     | 20th May 2021  | 17th Sept 2021  | 27th Aug 2021  |
| Control Flow 2 - Pattern Matching |      100% |      100% | -     | 20th Sept 2021 | 9th Dec 2021    | 29th Nov 2021  |
| Macros and cfg expansion          |       70% |           |       | 1st Dec 2021   | -               | 28th Mar 2022  |
| Imports and Visibility            |        0% |        0% | -     | 29th Mar 2022  | -               | 27th May 2022  |
| Const Generics                    |        0% |        0% | -     | 30th May 2022  | -               | 25th Jul 2022  |
| Intrinsics and builtins           |        0% |        0% | -     | 6th Sept 2021  | -               | 30th Sept 2022 |

*** Risks

| Risk                    | Impact (1-3) | Likelihood (0-10) | Risk (I * L) | Mitigation                                                 |
|-------------------------+--------------+-------------------+--------------+------------------------------------------------------------|
| Rust Language Changes   |            3 |                 7 |           21 | Keep up to date with the Rust language on a regular basis  |
| Going over target dates |            2 |                 5 |           10 | Maintain status reports and issue tracking to stakeholders |


** Planned Activities

- Finish supporting in place macro expansion
- Merge final PR for Slices
- Fix dynamic traits to support inheritance
 
** Detailed changelog

*** Implement proper repetition separators

Rust allows users to define separators to use in macro repetitions. These separators help in making repeating macro invocations cleaner, and avoid this:
#+BEGIN_SRC rust
macro_rules! add0 {
    ($a:literal) => { $a };
    ($a:literal $($b:literal)+) => { $a + add0!($($b)*) }
}

macro_rules! add1 {
    ($a:literal,) => { $a };
    ($a:literal, $($b:literal,)+) => { $a + add1!($($b ,)*) }
}

add0!(1 2 3 4 67); // no separator
add1!(1, 2, 3, 4, 67,); // extra separator
#+END_SRC

Macro repetition separators are made of one token and positionned just before the repetition operator (~?~, ~*~ or ~+~). We can now parse them, match them and expand them properly:

#+BEGIN_SRC rust
macro_rules! add {
    ($a:literal) => { $a };
    ($a:literal, $($b:literal),+) => { $a + add!($($b),*) }
}

add!(1, 2, 3, 4, 67);
#+END_SRC

*** Defining items and statements through macros

Macros can be used to avoid boilerplate and repetitive code, such as defining a large amount of types and their implementation should they all be similar.

This can be seen in the standard rust library in various builtin-types related code:

#+BEGIN_SRC rust
// Reduced version.
// This implements the `Sub` trait for all builtin number types
// The implementation is always the same, so macros help
pub trait Sub<Rhs = Self> {
    type Output;
    fn sub(self, rhs: Rhs) -> Self::Output;
}

macro_rules! sub_impl {
    ($($t:ty)*) => ($(
        impl Sub for $t {
            type Output = $t;

            #[inline]
            fn sub(self, other: $t) -> $t { self - other }
        }
    )*)
}

sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }
#+END_SRC

This expands to a proper implementation of the ~Sub~ trait for all types mentioned, with proper expansion of the ~sub~ method and associated ~Output~ type. We are now able to parse those items correctly and expand them in place.

Likewise, macro invocations can also be expanded to multiple statements inside a block:
#+BEGIN_SRC rust
macro_rules! define_vars {
    ($([ $name:ident $value:literal ])*) => {
        $(let $name = $value;)*
    }
}

fn needs_lots_of_locals() {
    define_vars!([pear 14] [apple 'm'] [mango "Pi"]);
}
#+END_SRC
